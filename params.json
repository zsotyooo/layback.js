{"name":"Layback.js","tagline":"Dare to be lazy! Create your javascript, add features to it, and make it reusable for the next time.","body":"# layback.js\r\n\r\nAs a developer I always kept reusability in mind.\r\n\r\nIn my everyday work I kept facing the same issues when I had to create some simple javascript code:\r\n\r\n> I should be able to somehow pass settings to my object...\r\n> Reaching the dom objects would be nice...\r\n> I should be able to use events observers...\r\n> I can make it as a jQuery plugin with some extra work...\r\n> I have items inside...\r\n> Oh, it should work a different way on mobile...\r\n> Wait, haven't I already done these things before?\r\n\r\nSo I started thinking. I need a simple, lightweight solution to enpower my javascript objects with different kind of features.\r\nSomething like this would be nice:\r\n```javascript\r\nvar MyClass = function(options) {\r\n\tthis.layback(options);\r\n\t\r\n\t// Do my stuff here\r\n}\r\n\r\nlayback(MyClass) // At this pont I have data access, observer implementation, and dom access\r\n\t.setDefaults({\r\n\t\tdata: {\r\n\t\t\tdummy: 'foo',\r\n\t\t\tsomething: 'cool'\r\n\t\t},\r\n\t\tdom: {\r\n\t\t\tbody: 'body'\r\n\t\t}\r\n\t})\r\n\t.treat('jQuery-plugin', 'myPlugin') // myPlugin jQuery plugin created\r\n\t.treat('collection') // items and collection methods added\r\n\t.make();\r\n```\r\n\r\n# Documentation\r\n\r\n## Applying layback to you Function Objects\r\nThere are two ways to apply the layback features to your function.\r\n#### Adding feautres after creating a function\r\n```javascript\r\nvar Creature = function (properties) {\r\n    this.layback(properties);\r\n    this.eat = function() {\r\n        this.dispatch('before-eating');\r\n        this.set('hunger', this.get('hunger')-1);\r\n        this.set('stamina', this.get('stamina')+1);\r\n        this.dispatch('after-eating');\r\n        return this;\r\n    }\r\n}\r\nlayback(Creature).make();\r\n\r\nvar creature = new Creature({hunger: 100, stamina: 10});\r\ncreature.eat().get('hunger'); // 99\r\ncreature.get('stamina'); // 11\r\n```\r\n#### Creating a function via layback\r\n*Note that the Function will be created globally accessable (in window)*\r\n```javascript\r\nlayback('Creature', function (properties) {\r\n    this.layback(properties);\r\n    this.eat = function() {\r\n        //...\r\n    }\r\n}).make();\r\n//...\r\n```\r\n## Data handling\r\nData handling is pretty simple. You can set default values for all the data you'd like to use, and you can use tham pretty flexible.\r\n### Setting the default data\r\nThe default data sets defaults values to all the data accessable inside the object. You can do it by calling the `setDefaults` function while adding the layout features.\r\n```javascript\r\nlayback('Creature', function(properties) {\r\n//...\r\n})\r\n.setDefaults({\r\n    data: { // This is a data namespace (explained later)\r\n        hunger: 0,\r\n        stamina: 100\r\n    }\r\n})\r\n.make();\r\nvar creature = new Creature();\r\ncreature.get('hunger'); // 0\r\ncreature.get('stamina'); // 100\r\n```\r\n\r\n## The treats\r\nThe treats are adding extra features to your function. This is the heart of layback.js.\r\n\r\nThere are 2 different kinds of treats:\r\n* **Sytem treats:** Automatically applied on your function when you call `.make()`.\r\n* **Optional treats:** You have to add them yourselves by calling the `.treat(treatName)` function.\r\n\r\n### Data treat (system)\r\nIt allows you to access data inside the object, it also automatically handles the options you pass to the `this.layback(options)` function.\r\n#### Added features\r\n* `get(dataName, [default])`: It gets a data. If it doesnt exist can get the `default` value back.\r\n* `set(dataName, dataValue)`: It sets a data with the key on `dataName`, and the value of `dataValue`.\r\n\r\n#### Example usage\r\n```javascript\r\nlayback('Creature', function(properties) {\r\n    // You can set some defaults here as well, only for the \"data\" namespace.\r\n    // It comes in handy when you have to do some pre calculations\r\n    this.laybackData = {\r\n        stamina: Math.round(Math.random() * 100)\r\n    };\r\n    this.layback(properties);\r\n    //...\r\n})\r\n.setDefaults({\r\n    data: {\r\n        hunger: 0,\r\n        stamina: 100\r\n    }\r\n})\r\n.make();\r\n\r\nvar creature1 = new Creature; // Using the default data only\r\ncreature1.get('hunger'); // 0\r\ncreature1.get('stamina'); // 1..100 random number\r\n\r\nvar creature2 = new Creature({hunger: 50}); // Using custom options\r\ncreature2.get('hunger'); // 50\r\ncreature2.get('stamina'); // 1..100 random number\r\n```\r\n### Event treat\r\nIt's a simple observer implementation.\r\n#### Added features\r\n* `dispatch(eventName, [eventData])`: It fires an avent with `eventName`, and you can dispatch exra data by using the `eventData` argument.\r\n* `observe(eventName, observerFunction)`: It observes the `eventName` event.\r\nThe observerFunction recieves the `observee` object, and the `eventData`.\r\n\r\n#### Using default observers\r\n```javascript\r\nlayback('Creature', function(properties) {\r\n    // You can set some default observers here as well\r\n    // It comes in handy when you have to do some pre calculations\r\n    this.laybackObservers = {\r\n        'after-stop-walking': {\r\n            toDo: function(obj, nextAction){// you can add more observers to the same event\r\n                obj.set('nextAction', nextAction);\r\n            }\r\n        }\r\n    }\r\n    this.layback(properties);\r\n    \r\n    this.startWalking = function() {\r\n        this.set('walking', true);\r\n        this.dispatch('after-start-walking');\r\n    }\r\n    \r\n    this.stopWalking = function(nextAction) {\r\n        this.set('walking', false);\r\n        this.dispatch('after-stop-walking', nextAction);\r\n    }\r\n    \r\n    //...\r\n})\r\n.setDefaults({\r\n    data: {\r\n        legs: 0\r\n    },\r\n    observers: {\r\n        'after-start-walking': {\r\n            canWalk: function(obj, data) {\r\n                if (obj.get('legs') == 0) {\r\n                    obj.stopWalking('idling');\r\n                }\r\n            }\r\n        }\r\n    }\r\n})\r\n.make();\r\n\r\nvar fish = new Creature({legs: 0});\r\nfish.startWalking(); // The observer has stopped the walking\r\nfish.get('walking'); // false\r\nfish.get('nextAction'); // idling\r\n\r\nvar cat = new Creature({legs: 4});\r\ncat.startWalking(); // The observer has not stopped the walking\r\ncat.get('walking'); // true\r\n```\r\n#### Using observers on-the-fly\r\n```javascript\r\ncat.observe('after-start-walking', function(obj) {\r\n    obj.liftTail();\r\n});\r\n```\r\n#### Using observers via options\r\n```javascript\r\nlayback(Creature).make();\r\nvar cat = new Creature({\r\n    legs: 4,\r\n    onAfterStartWalking: function(obj) {\r\n        obj.liftTail();\r\n    }\r\n});\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}